
	 Source file: lcs_with_pragma.c


	 Found pragma with struct_grid in line: 20 :  #pragma dynamic_prog mat dimensions 2


	 ^^^^ Number of dimensions is found  2

	 Found pragma with struct_grid in line: 21 :  #pragma dynamic_prog solve num_conditions 3


	 Found solve 21  #pragma dynamic_prog solve num_conditions 3


	 ** Found solve num_conditions in line 21 ** 

	 Found number of conditions for solve: 3 num_conditions_found 0 num_conditions 3

	 Found pragma with struct_grid in line: 22 :  #pragma dynamic_prog mat array lengths


	 ^^^^ Array is found  lengths

	 Found pragma with struct_grid in line: 27 :       #pragma dynamic_prog solve cond 1


	 Found solve 27       #pragma dynamic_prog solve cond 1


	 condn_term_key is cond1


	 ** Found the condition number       #pragma dynamic_prog solve cond 1 !! 

	 Did NOT find brace { on line: 28

	 Found brace { on line: 29

	 Did NOT find brace } on line: 30

	 Found brace } on line: 31

	 Did NOT find condition within () on line: 29

	 Found condition within () on line: 28

	 --- CONDN ALERT found a logical-equal operator! if (a[i] == b[j]) term-0: if (a[i]  term-1:  b[j])

	 LHS operands: 

	 # 0 term: a[i

	 # 1 term:  

	 Yo! lhs-term: 0 index--> i

	 NODAPPA len(operands_sqbrace1_split) 2

	 Number-of-groups in curr_term is 2 ,  b[j

	 j: 0  b

	 j: 1 j

	 -- Did not find any operator:  b and curr_operand is  b[j] Current idx is j

	 Number-of-groups in curr_term is 1 , ;

	 j: 0 ;

	 Hurray Semicolon detected!! 


	 -- NOTICE return_params['res']['rhs_operands'][i] is  b[j] and the indices are

		 index-no: 0 index --> j

	 Venturing to find statements from line 29

	 LHS operands: 

	 # 0 term: lengths[i+1

	 # 1 term: [j+1

	 # 2 term:  

	 Yo! lhs-term: 0 index--> i+1

	 Yo! lhs-term: 1 index--> j+1

	 NODAPPA len(operands_sqbrace1_split) 3

	 Number-of-groups in curr_term is 2 ,  lengths[i

	 j: 0  lengths

	 j: 1 i

	 -- Did not find any operator:  lengths and curr_operand is  lengths[i] Current idx is i

	 Number-of-groups in curr_term is 2 , [j

	 j: 0 

	 j: 1 j

	 -- Did not find any operator:  and curr_operand is  lengths[i][j] Current idx is j

	 Number-of-groups in curr_term is 1 ,  + 1 ;

	 j: 0  + 1 ;

	 -- FOUND a plus operator:   ,  1 ;

	 ++ Current idx: 	 and pass_new_operand is  1 

	 Disassemble the following operator!! 


	 K: 0  

	 K: 1  1 ;

	 Yes an operator has been found! 

	 -- NOTICE return_params['res']['rhs_operands'][i] is  lengths[i][j] and the indices are

		 index-no: 0 index --> i

		 index-no: 1 index --> j

	 condn_params[condn_term_key][statement_keywd']['eqn_params'][0] lengths[i+1][j+1] 

	 Found pragma with struct_grid in line: 32 :       #pragma dynamic_prog solve cond 2            


	 Found solve 32       #pragma dynamic_prog solve cond 2            


	 condn_term_key is cond2


	 ** Found the condition number       #pragma dynamic_prog solve cond 2 !! 

	 Did NOT find brace { on line: 33

	 Found brace { on line: 34

	 Did NOT find brace } on line: 35

	 Found brace } on line: 36

	 Did NOT find condition within () on line: 34

	 Found condition within () on line: 33

	 --- CONDN ALERT found a greater than operator! else if (  lengths[i+1][j] > lengths[i][j+1])  ) term-0: else if (  lengths[i+1][j]  term-1:  lengths[i][j+1])  )

	 Before sending find_condn_great_operator[0]   lengths[i+1][j]  find_condn_great_operator[1]  lengths[i][j+1];

	 LHS operands: 

	 # 0 term:   lengths[i+1

	 # 1 term: [j

	 # 2 term:  

	 Yo! lhs-term: 0 index--> i+1

	 Yo! lhs-term: 1 index--> j

	 NODAPPA len(operands_sqbrace1_split) 3

	 Number-of-groups in curr_term is 2 ,  lengths[i

	 j: 0  lengths

	 j: 1 i

	 -- Did not find any operator:  lengths and curr_operand is  lengths[i] Current idx is i

	 Number-of-groups in curr_term is 2 , [j+1

	 j: 0 

	 j: 1 j+1

	 -- Did not find any operator:  and curr_operand is  lengths[i][j+1] Current idx is j+1

	 Number-of-groups in curr_term is 1 , ;

	 j: 0 ;

	 Hurray Semicolon detected!! 


	 -- NOTICE return_params['res']['rhs_operands'][i] is  lengths[i][j+1] and the indices are

		 index-no: 0 index --> i

		 index-no: 1 index --> j+1

	 --**&&^^  condn_params[condn_term_key]['condn_unrolled']['eqn_params'][0]   lengths[i+1][j] 

	 Venturing to find statements from line 34

	 LHS operands: 

	 # 0 term: lengths[i+1

	 # 1 term: [j+1

	 # 2 term:  

	 Yo! lhs-term: 0 index--> i+1

	 Yo! lhs-term: 1 index--> j+1

	 NODAPPA len(operands_sqbrace1_split) 5

	 Number-of-groups in curr_term is 3 ,  lengths[i+1-duh[i

	 j: 0  lengths

	 j: 1 i+1-duh

	 j: 2 i

	 Index has plus operator!! i+1-duh len(idx_split) 2

	 ++ Did not find any operator:  lengths and curr_operand is  lengths[i+1-duh[i] Current idx is i+1-duh[i]

	 Number-of-groups in curr_term is 1 , 

	 j: 0 

	 Space found instead of semicolon detected!! 

	 Number-of-groups in curr_term is 2 , [j

	 j: 0 

	 j: 1 j

	 -- Did not find any operator:  and curr_operand is  lengths[i+1-duh[i]][j] Current idx is j

	 Number-of-groups in curr_term is 2 ,  + duh[i

	 j: 0  + duh

	 j: 1 i

	 -- FOUND a plus operator:   ,  duh

	 -- Current idx: i	 and pass_new_operand is  duh[i]

	 Disassemble the following operator!! 


	 K: 0  

	 K: 1  duh

	 Yes an operator has been found! 

	 Number-of-groups in curr_term is 1 ,  ;

	 j: 0  ;

	 FATAL: Semicolon detection has a BUG!!!!  ; length of test_semicolon 2    end

	 -- NOTICE return_params['res']['rhs_operands'][i] is  lengths[i+1-duh[i]][j] and the indices are

		 index-no: 0 index --> i+1-duh[i]

		 index-no: 1 index --> j

	 condn_params[condn_term_key][statement_keywd']['eqn_params'][0] lengths[i+1][j+1] 

	 Found pragma with struct_grid in line: 37 :       #pragma dynamic_prog solve cond 3   	    


	 Found solve 37       #pragma dynamic_prog solve cond 3   	    


	 condn_term_key is cond3


	 ** Found the condition number       #pragma dynamic_prog solve cond 3 !! 

	 Did NOT find brace { on line: 38

	 Found brace { on line: 39

	 Did NOT find brace } on line: 40

	 Found brace } on line: 41

	 Did NOT find condition within () on line: 39

	 Found 'else' instead of condition             else


	 --- CONDN ALERT found an else operator! else

	 Venturing to find statements from line 39

	 LHS operands: 

	 # 0 term: lengths[i+1

	 # 1 term: [j+1

	 # 2 term:  

	 Yo! lhs-term: 0 index--> i+1

	 Yo! lhs-term: 1 index--> j+1

	 NODAPPA len(operands_sqbrace1_split) 3

	 Number-of-groups in curr_term is 2 ,  lengths[i

	 j: 0  lengths

	 j: 1 i

	 -- Did not find any operator:  lengths and curr_operand is  lengths[i] Current idx is i

	 Number-of-groups in curr_term is 2 , [j+1

	 j: 0 

	 j: 1 j+1

	 -- Did not find any operator:  and curr_operand is  lengths[i][j+1] Current idx is j+1

	 Number-of-groups in curr_term is 1 , ;

	 j: 0 ;

	 Hurray Semicolon detected!! 


	 -- NOTICE return_params['res']['rhs_operands'][i] is  lengths[i][j+1] and the indices are

		 index-no: 0 index --> i

		 index-no: 1 index --> j+1

	 condn_params[condn_term_key][statement_keywd']['eqn_params'][0] lengths[i+1][j+1] 

	 Found pragma with struct_grid in line: 44 :    #pragma dynamic_prog solve cond 4


	 Found solve 44    #pragma dynamic_prog solve cond 4


	 I go nowhere!! since num_conditions_found is 3 and num_conditions is 3 :'( :'( 

	 Found pragma with struct_grid in line: 57 :     #pragma dynamic_prog solve cond 5


	 Found solve 57     #pragma dynamic_prog solve cond 5


	 I go nowhere!! since num_conditions_found is 3 and num_conditions is 3 :'( :'( 

	 ------------------------------------------------------------------------------------------ 

	 Summarizing the condtions: 
 

	 Number of conditions: 3

	 I am condition number: 0

		 Condn: 28

		 Is else condn: 0

			 LHS: a[i] 

			 RHS-operator 0 -->  b[j] and the indices are

				 index-no: 0 index --> j

	 Condition expression: a[i]  ==   b[j]  

	 Condition :            if (a[i] == b[j])


		 statement: lengths[i+1][j+1] = lengths[i][j] + 1 ;

			 LHS: lengths[i+1][j+1] 	 RHS:  lengths[i][j] + 1 ;

			 RHS-operator 0 -->  lengths[i][j] and the indices are

				 index-no: 0 index --> i

				 index-no: 1 index --> j

	 Inserting set_condn_num: 	 test_condn=1 test_condn: 1 i: 0 condn_term_key cond1

	 I am condition number: 1

		 Condn: 33

		 Is else condn: 0

			 LHS:   lengths[i+1][j] 

			 RHS-operator 0 -->  lengths[i][j+1] and the indices are

				 index-no: 0 index --> i

				 index-no: 1 index --> j+1

	 Condition expression:   lengths[i+1][j]  >   lengths[i][j+1]  

	 Condition :            else if (  lengths[i+1][j] > lengths[i][j+1])  )


		 statement: lengths[i+1][j+1] = lengths[i+1-duh[i]][j] + duh[i] ;

			 LHS: lengths[i+1][j+1] 	 RHS:  lengths[i+1-duh[i]][j] + duh[i] ;

			 RHS-operator 0 -->  lengths[i+1-duh[i]][j] and the indices are

				 index-no: 0 index --> i+1-duh[i]

				 index-no: 1 index --> j

	 Inserting set_condn_num: 	 test_condn=2 test_condn: 2 i: 1 condn_term_key cond2

	 I am condition number: 2

		 Condn: 38

		 Is else condn: 1

		 statement: lengths[i+1][j+1] = lengths[i][j+1];

			 LHS: lengths[i+1][j+1] 	 RHS:  lengths[i][j+1];

			 RHS-operator 0 -->  lengths[i][j+1] and the indices are

				 index-no: 0 index --> i

				 index-no: 1 index --> j+1

	 Inserting set_condn_num: 	 test_condn=3 test_condn: 3 i: 2 condn_term_key cond3

	 ----------------------------------------------------------------------------------- 


	 These are the condition(s) and other statments going to the method int rollback() 


	             if (a[i] == b[j])


	 {

	 	lengths[i+1][j+1] = lengths[i][j] + 1 ;

	 	 test_condn=1

	 }

	             else if (  lengths[i+1][j] > lengths[i][j+1])  )


	 {

	 	lengths[i+1][j+1] = lengths[i+1-duh[i]][j] + duh[i] ;

	 	 test_condn=2

	 }

	 else

	 {

	 	lengths[i+1][j+1] = lengths[i][j+1];

	 	 test_condn=3

	 }

	 LHS-index: i+1

	 LHS-index: j+1

	 The lhs_operand is same as that of 'fill_array' lengths

	 The rhs_operand is same as that of 'fill_array' lengths

	 LHS-idx has 2 terms and RHS-idx has 1 terms!! 

		 LHS-operator 0 index: i+1 rhs-index i use_idx 0

	 LHS-idx has 2 terms and RHS-idx has 1 terms!! 

		 LHS-operator 0 index: j+1 rhs-index j use_idx 0

	 LHS-index: i+1

	 LHS-index: j+1

	 The lhs_operand is same as that of 'fill_array' lengths

	 The rhs_operand is same as that of 'fill_array' lengths

	 Index also has a minus term !! 

	 LHS-idx has 2 terms and RHS-idx has 3 terms!! 

		 LHS-operator 0 index: i+1 rhs-index i+1-duh[i] use_idx 0

	 LHS-idx has 2 terms and RHS-idx has 1 terms!! 

		 LHS-operator 0 index: j+1 rhs-index j use_idx 0

	 LHS-index: i+1

	 LHS-index: j+1

	 The lhs_operand is same as that of 'fill_array' lengths

	 The rhs_operand is same as that of 'fill_array' lengths

	 LHS-idx has 2 terms and RHS-idx has 1 terms!! 

		 LHS-operator 0 index: i+1 rhs-index i use_idx 0

	 LHS-idx has 2 terms and RHS-idx has 2 terms!! 

		 LHS-operator 0 index: j+1 rhs-index j+1 use_idx 0
